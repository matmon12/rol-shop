import { ref, computed, watch } from "vue";
var VueYandexMaps;
((VueYandexMaps2) => {
  VueYandexMaps2.settings = safeRef({
    apikey: ""
  });
  VueYandexMaps2.ymaps = () => ymaps3;
  class YandexMapException2 extends Error {
    constructor(message) {
      super(message);
      this.message = message;
      this.name = "YandexMapException";
    }
  }
  VueYandexMaps2.YandexMapException = YandexMapException2;
  VueYandexMaps2.loadStatus = safeRef("pending");
  VueYandexMaps2.isLoaded = safeComputed(() => VueYandexMaps2.loadStatus.value === "loaded" || VueYandexMaps2.loadStatus.value === "error");
  VueYandexMaps2.loadError = safeRef(null);
})(VueYandexMaps || (VueYandexMaps = {}));
function safeRef(value) {
  if (typeof window === "undefined") {
    return {
      // @ts-ignore
      value,
      // @ts-ignore
      __v_isRef: true
    };
  }
  return ref(value);
}
function safeComputed(getter, debugOptions) {
  if (typeof window === "undefined") {
    return {
      get value() {
        return getter();
      },
      // @ts-ignore
      __v_isRef: true
    };
  }
  return computed(getter, debugOptions);
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function copy(target) {
  if (Array.isArray(target))
    return target.map((i) => copy(i));
  if (!target || typeof target !== "object" || (target == null ? void 0 : target.constructor) !== void 0 && (target == null ? void 0 : target.constructor) !== Object)
    return target;
  return Object.keys(target).reduce((carry, key) => {
    const val = target[key];
    carry[key] = copy(val);
    return carry;
  }, {});
}
function isDev() {
  var _a;
  return typeof process !== "undefined" && (((_a = process.env) == null ? void 0 : _a.NODE_ENV) === "development" || process.dev);
}
function getException({ text, isInternal, warn }) {
  if (warn) {
    text = `Warning: ${text}`;
  }
  if (isInternal) {
    text += " This is likely Vue Yandex Maps internal bug.";
    if (isDev()) {
      text += " You can report this bug here: https://github.com/PNKBizz/vue-yandex-maps/issues/new/choose";
    }
  }
  return new VueYandexMaps.YandexMapException(text);
}
function throwException(settings) {
  const exception = getException(settings);
  if (settings.warn) {
    console.warn(exception);
  } else {
    throw exception;
  }
}
function excludeKeys(item, ignoreKeys) {
  for (const [key, value] of Object.entries(item)) {
    if (ignoreKeys.includes(key))
      delete item[key];
    if (value && typeof value === "object" && !Array.isArray(value)) {
      excludeKeys(value, ignoreKeys);
      if (!Object.keys(value).length)
        delete item[key];
    }
  }
}
const YandexMapException = VueYandexMaps.YandexMapException;
const allowedOptionsKeys = {
  apikey: true,
  lang: true,
  initializeOn: true,
  importModules: true,
  version: true,
  strictMode: true,
  domain: true,
  mapsRenderWaitDuration: true,
  mapsScriptWaitDuration: true
};
function initYmaps() {
  return new Promise((res, rej) => {
    if (typeof ymaps3 !== "undefined")
      return res();
    if (typeof window === "undefined")
      return rej(new YandexMapException("You must call initYmaps on Client Side only"));
    if (document.getElementById("vue-yandex-maps")) {
      const watcher = watch(VueYandexMaps.loadStatus, (val) => {
        if (!VueYandexMaps.isLoaded.value)
          return;
        watcher();
        if (val === "error")
          rej(VueYandexMaps.loadError);
        if (val === "loaded")
          res();
      }, {
        immediate: true
      });
      return;
    }
    VueYandexMaps.loadStatus.value = "loading";
    const settings = VueYandexMaps.settings.value;
    const yandexMapScript = document.createElement("SCRIPT");
    const url = new URL(`${settings.domain}/${settings.version}/`);
    url.searchParams.set("lang", settings.lang || "ru_RU");
    url.searchParams.set("apikey", settings.apikey);
    yandexMapScript.setAttribute("src", url.toString());
    yandexMapScript.setAttribute("async", "");
    yandexMapScript.setAttribute("defer", "");
    yandexMapScript.setAttribute("type", "text/javascript");
    yandexMapScript.setAttribute("id", "vue-yandex-maps");
    document.head.appendChild(yandexMapScript);
    yandexMapScript.onload = async () => {
      try {
        await VueYandexMaps.ymaps().ready;
        if (settings.strictMode)
          VueYandexMaps.ymaps().strictMode = true;
        if (settings.importModules) {
          await Promise.all(
            settings.importModules.map(
              (module) => VueYandexMaps.ymaps().import(module)
            )
          );
        }
        VueYandexMaps.loadStatus.value = "loaded";
        res();
      } catch (e) {
        VueYandexMaps.loadStatus.value = "error";
        VueYandexMaps.loadError.value = e;
        rej(e);
      }
    };
    yandexMapScript.onerror = (e) => {
      VueYandexMaps.loadError.value = e;
      rej(e);
    };
  });
}
function createYmapsOptions(options) {
  const optionsShallowClone = {
    lang: "ru_RU",
    initializeOn: "onComponentMount",
    importModules: [],
    version: "v3",
    strictMode: false,
    domain: "https://api-maps.yandex.ru",
    mapsRenderWaitDuration: true,
    mapsScriptWaitDuration: true,
    ...options
  };
  if (!optionsShallowClone.apikey) {
    throwException({
      text: "You must specify apikey for createYmapsOptions"
    });
  }
  const notAllowedKeys = Object.keys(optionsShallowClone).filter((key) => !(key in allowedOptionsKeys));
  if (notAllowedKeys.length) {
    throwException({
      text: `You have passed unknown keys to createYmapsOptions: ${notAllowedKeys.join(", ")}. Only ${Object.keys(allowedOptionsKeys).join(", ")} are allowed.`
    });
  }
  VueYandexMaps.settings.value = optionsShallowClone;
  return optionsShallowClone;
}
export {
  VueYandexMaps as V,
  copy as a,
  createYmapsOptions as c,
  excludeKeys as e,
  getException as g,
  initYmaps as i,
  sleep as s,
  throwException as t
};
