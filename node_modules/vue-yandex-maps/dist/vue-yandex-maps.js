import "./vue-yandex-maps.css";
import { t as throwException, g as getException, c as createYmapsOptions, V as VueYandexMaps, i as initYmaps, a as copy, e as excludeKeys, s as sleep } from "./vue-yandex-maps-fHw_W40B.js";
import { defineComponent, shallowRef, ref, provide, computed, onMounted, nextTick, watch, onBeforeUnmount, h, toRaw, getCurrentInstance, inject, isRef } from "vue";
function applyModifier(coords, modifier) {
  const result = {
    x: 0,
    y: 0
  };
  result.x = coords.x * modifier;
  result.y = coords.y * modifier;
  return result;
}
function applyFunctionModifier(coords, functionModifier) {
  const result = {
    x: 0,
    y: 0
  };
  result.x = functionModifier(coords.x, 1);
  result.y = functionModifier(coords.y, 2);
  return result;
}
function worldToPixels(coords, modifier) {
  const i = 2 ** modifier / 2 * 256;
  return applyModifier({
    x: coords.x + 1,
    y: 1 - coords.y
  }, i);
}
function convertWorldCoordinates(projection, coordinates, modifier) {
  const worldCoordinates = projection.toWorldCoordinates(coordinates);
  return worldToPixels(worldCoordinates, modifier);
}
function pixelsToWorld(coords, modifier) {
  const i = 2 ** modifier / 2 * 256;
  return {
    x: coords.x / i - 1,
    y: 1 - coords.y / i
  };
}
function findNeededValue(t, e, i) {
  return Math.max(Math.min(t, i), e);
}
function worldCoordsFromModifier(projection, coords, modifier) {
  const resultCoords = applyFunctionModifier(pixelsToWorld(coords, modifier), (value) => findNeededValue(value, -1, 1 - 1e-15));
  return projection.fromWorldCoordinates(resultCoords);
}
function convertBounds(projection, bounds, modifier) {
  const topLeft = convertWorldCoordinates(projection, bounds[0], modifier);
  const bottomRight = convertWorldCoordinates(projection, bounds[1], modifier);
  const modified = 2 ** modifier * 256;
  const updatedBounds = [[topLeft.x, topLeft.y], [bottomRight.x, bottomRight.y]];
  if (topLeft.x > bottomRight.x) {
    updatedBounds[0][0] = topLeft.x;
    updatedBounds[1][0] = bottomRight.x + modified;
  }
  if (topLeft.y > bottomRight.y) {
    updatedBounds[0][1] = bottomRight.y;
    updatedBounds[1][1] = topLeft.y;
  }
  return updatedBounds;
}
function applyMarginToCoords(coords, margin) {
  return {
    x: Math.max(coords.x - (margin ? margin[1] + margin[3] : 0), 1),
    y: Math.max(coords.y - (margin ? margin[0] + margin[2] : 0), 1)
  };
}
function findZoom(projection, bounds, coords, isSnap, zoomRange) {
  const [[topLeftFirst, topLeftSecond], [bottomRightFirst, bottomRightSecond]] = convertBounds(projection, bounds, 0);
  const firstCalc = Math.max(Math.abs(bottomRightFirst - topLeftFirst), 1e-10);
  const secondCalc = Math.max(Math.abs(bottomRightSecond - topLeftSecond), 1e-10);
  const zoom = findNeededValue(Math.min(Math.log2(coords.x / firstCalc), Math.log2(coords.y / secondCalc)), zoomRange.min, zoomRange.max);
  return isSnap ? Math.floor(zoom + 1e-6) : zoom;
}
function findCenter(projection, bounds, zoom) {
  const [[topLeftFirst, topLeftSecond], [bottomRightFirst, bottomRightSecond]] = convertBounds(projection, bounds, zoom);
  return worldCoordsFromModifier(projection, {
    x: (topLeftFirst + bottomRightFirst) / 2,
    y: (topLeftSecond + bottomRightSecond) / 2
  }, zoom);
}
async function useYMapsLocationFromBounds({
  bounds,
  map
}) {
  var _a;
  const ctxMap = Object.keys(map).find((x) => x.endsWith("CtxMap"));
  if (!ctxMap) {
    throwException({
      text: "CtxMap was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const ctx = map[ctxMap];
  const ctxItem = await new Promise((resolve, reject) => {
    ctx.forEach((item, { name }) => {
      if (name !== "map")
        return;
      resolve(item);
    });
    reject(getException({
      text: "Map item was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    }));
  });
  const ctxItemMapKey = Object.keys(ctxItem).find((x) => x.endsWith("_context"));
  if (!ctxItemMapKey) {
    throwException({
      text: "CtxMapKey was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const ctxItemMap = ctxItem[ctxItemMapKey].map;
  const boundsFunc = ctxItemMap.setBounds.toString();
  const funcKey = (_a = boundsFunc.split("const{center:e,zoom:i}=")[1]) == null ? void 0 : _a.split("(")[0];
  if (!funcKey) {
    throwException({
      text: "funcKey was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const projection = ctxItemMap.projection;
  const size = ctxItemMap.size;
  const margin = ctxItemMap.margin;
  const isSnap = ctxItemMap.effectiveZoomRounding === "snap";
  const zoomRange = ctxItemMap.zoomRange;
  const zoom = findZoom(projection, bounds, applyMarginToCoords(size, margin), isSnap, zoomRange);
  return {
    zoom,
    center: findCenter(projection, bounds, zoom)
  };
}
function createYmaps(settings) {
  return {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    install(app) {
      createYmapsOptions(settings);
    }
  };
}
function createYmapsVue2(settings) {
  return {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    install(Vue) {
      createYmapsOptions(settings);
    }
  };
}
const isDate = (d) => d instanceof Date;
const isEmpty = (o) => Object.keys(o).length === 0;
const isObject = (o) => o != null && typeof o === "object";
const hasOwnProperty = (o, ...args) => Object.prototype.hasOwnProperty.call(o, ...args);
const isEmptyObject = (o) => isObject(o) && isEmpty(o);
const makeObjectWithoutPrototype = () => /* @__PURE__ */ Object.create(null);
const diff = (lhs, rhs) => {
  if (lhs === rhs)
    return {};
  if (!isObject(lhs) || !isObject(rhs))
    return rhs;
  const deletedValues = Object.keys(lhs).reduce((acc, key) => {
    if (!hasOwnProperty(rhs, key)) {
      acc[key] = void 0;
    }
    return acc;
  }, makeObjectWithoutPrototype());
  if (isDate(lhs) || isDate(rhs)) {
    if (lhs.valueOf() == rhs.valueOf())
      return {};
    return rhs;
  }
  return Object.keys(rhs).reduce((acc, key) => {
    if (!hasOwnProperty(lhs, key)) {
      acc[key] = rhs[key];
      return acc;
    }
    const difference = diff(lhs[key], rhs[key]);
    if (isEmptyObject(difference) && !isDate(difference) && (isEmptyObject(lhs[key]) || !isEmptyObject(rhs[key])))
      return acc;
    acc[key] = difference;
    return acc;
  }, deletedValues);
};
const _sfc_main$m = defineComponent({
  name: "YandexMap",
  props: {
    modelValue: {
      type: Object,
      default: null
    },
    value: {
      type: Object,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    },
    width: {
      type: String,
      default: "100%"
    },
    height: {
      type: String,
      default: "100%"
    },
    // z-index for Map Container. Without this, elements of the map will be displayed under your site's elements due to high z-index inside of them
    zIndex: {
      type: Number,
      default: 0
    },
    /**
     * @description Settings for cart initialization.,
     *
     * You can modify this object or use map methods, such as setLocation/setBehaviors e.t.c.
     * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#map-parms
     * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#map-parms
     */
    settings: {
      type: Object,
      required: true
    },
    /**
     * @description Makes settings readonly. Enable this if reactivity causes problems
     */
    readonlySettings: {
      type: Boolean,
      default: false
    },
    /**
     * @description Always inserts actual user center or bounds (based on your input) on every location change
     * @note This prop will cause user location change on every settings update (if user did move since last time). Use it with caution.
     */
    realSettingsLocation: {
      type: Boolean,
      default: false
    },
    /**
     * @description You can also add layers through <yandex-*> components
     *
     * Modifying this object after mount will cause no effect.
     *
     * Instead, please use map methods, such as addChild.
     * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#layers
     * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#layers
     */
    layers: {
      type: Array,
      default: () => []
    },
    /**
     * @description Adds cursor: grab/grabbing to ymaps scheme layer
     */
    cursorGrab: {
      type: Boolean,
      default: false
    }
  },
  /**
   * @description Other events are NOT available. You can listen to events via layers prop, addChildren prop or by adding <ymap-listener> as children.
   * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/events.html
   * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/events.html
   */
  emits: {
    "input"(map) {
      return !map || typeof ymaps3 === "undefined" || map instanceof ymaps3.YMap;
    },
    "update:modelValue"(map) {
      return !map || typeof ymaps3 === "undefined" || map instanceof ymaps3.YMap;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const map = shallowRef(null);
    const layers = shallowRef([]);
    const projection = shallowRef(null);
    const ymapContainer = ref(null);
    const mounted = shallowRef(false);
    const grabbing = shallowRef(false);
    const needsToHold = ref(0);
    provide("map", map);
    provide("layers", layers);
    provide("projection", projection);
    provide("needsToHold", needsToHold);
    emit("input", map.value);
    emit("update:modelValue", map.value);
    const getSettings = computed(() => ({
      ...props.settings,
      projection: void 0
    }));
    const init = async () => {
      if (!props.settings.location) {
        throwException({
          text: "You must specify location in YandexMap settings"
        });
      }
      const container = ymapContainer.value;
      if (!container) {
        throwException({
          text: "<yandex-map> container is undefined after component mount.",
          isInternal: true
        });
      }
      if (map.value)
        map.value.destroy();
      const settings = getSettings.value;
      if (projection.value)
        settings.projection = projection.value;
      const createdMap = new ymaps3.YMap(container, settings, [
        ...layers.value,
        ...props.layers
      ]);
      map.value = createdMap;
      emit("input", map.value);
      emit("update:modelValue", map.value);
    };
    onMounted(async () => {
      if (!VueYandexMaps.isLoaded.value) {
        if (VueYandexMaps.settings.value.initializeOn === "onComponentMount") {
          try {
            await initYmaps();
          } catch (e) {
            console.error("An error occured while initializing Yandex Map with onComponentMount setting");
            console.error(e);
            return;
          }
        } else {
          throwException({
            text: "You have set up <yandex-map> component without initializing Yandex maps. Please check initializeOn setting or call initYmaps manually before registering this component."
          });
        }
      }
      mounted.value = true;
      await nextTick();
      if (needsToHold.value) {
        await new Promise((resolve) => watch(needsToHold, () => {
          if (!needsToHold.value)
            resolve();
        }, {
          immediate: true
        }));
      }
      await init();
      let listener;
      const setupWatcher = () => {
        let settings = JSON.parse(JSON.stringify(toRaw(getSettings.value)));
        watch(getSettings, (val) => {
          var _a;
          const rawVal = toRaw(val);
          const clonedSettings = JSON.parse(JSON.stringify(rawVal));
          if (props.realSettingsLocation && clonedSettings.location && map.value) {
            if ("center" in clonedSettings.location && "center" in settings.location) {
              settings.location.center = map.value.center;
            } else if ("bounds" in clonedSettings.location && "bounds" in settings.location) {
              settings.location.bounds = map.value.bounds;
            }
            if ("zoom" in clonedSettings.location && "zoom" in settings.location)
              settings.location.zoom = map.value.zoom;
          }
          const settingsDiff = Object.keys(diff(settings, clonedSettings));
          if (settingsDiff.length === 0)
            return;
          const updatedSettings = { ...clonedSettings };
          for (const key in updatedSettings) {
            if (!settingsDiff.includes(key))
              delete updatedSettings[key];
          }
          settings = clonedSettings;
          (_a = map.value) == null ? void 0 : _a.update(updatedSettings);
        }, {
          deep: true
        });
      };
      if (!props.readonlySettings) {
        setupWatcher();
      }
      watch(() => props.readonlySettings, (val) => {
        if (!val)
          ;
        else {
          setupWatcher();
        }
      });
      watch(() => props.cursorGrab, (val) => {
        if (!map.value)
          return;
        if (val) {
          listener = new ymaps3.YMapListener({
            onActionStart: (e) => {
              if (e.type === "drag")
                grabbing.value = true;
            },
            onActionEnd: (e) => {
              if (e.type === "drag")
                grabbing.value = false;
            }
          });
          map.value.addChild(listener);
        } else if (listener)
          map.value.removeChild(listener);
      }, { immediate: true });
    });
    onBeforeUnmount(() => {
      map.value = null;
      emit("input", map.value);
      emit("update:modelValue", map.value);
    });
    return () => {
      var _a;
      const mapNodeProps = {
        class: [
          "__ymap",
          {
            "__ymap--grab": props.cursorGrab,
            "__ymap--grabbing": props.cursorGrab && grabbing.value
          }
        ],
        style: {
          width: props.width,
          height: props.height,
          "z-index": props.zIndex.toString()
        }
      };
      const containerNode = h("div", {
        class: "__ymap_container",
        ref: ymapContainer
      });
      const slotsNodeProps = {
        class: "__ymap_slots",
        style: { display: "none" }
      };
      if (!mounted.value)
        return h(props.tag, mapNodeProps, [containerNode, h("div", slotsNodeProps)]);
      return h(props.tag, mapNodeProps, [
        containerNode,
        h("div", slotsNodeProps, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
function injectMap() {
  if (!getCurrentInstance()) {
    throwException({
      text: "injectMap must be only called on runtime.",
      isInternal: true
    });
  }
  const map = inject("map");
  if (!map || !isRef(map)) {
    throwException({
      text: "Was not able to inject valid map in injectMap.",
      isInternal: true
    });
  }
  return map;
}
function injectLayers() {
  if (!getCurrentInstance()) {
    throwException({
      text: "injectLayers must be only called on runtime.",
      isInternal: true
    });
  }
  const layers = inject("layers");
  if (!layers || !isRef(layers)) {
    throwException({
      text: "Was not able to inject valid layers in injectLayers.",
      isInternal: true
    });
  }
  return layers;
}
function waitTillYmapInit({ timeoutCallback } = {}) {
  if (typeof window === "undefined") {
    throwException({
      text: "waitTillYmapInit cannot be called on SSR.",
      isInternal: true
    });
  }
  if (typeof ymaps3 !== "undefined")
    return;
  return new Promise((resolve, reject) => {
    if (typeof ymaps3 === "undefined") {
      let timeout;
      if (VueYandexMaps.settings.value.mapsScriptWaitDuration !== false) {
        timeout = setTimeout(() => {
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
          reject(new VueYandexMaps.YandexMapException("Was not able to wait for map initialization in waitTillYmapInit. Ensure that map was initialized. You can change this behaviour by using mapsScriptWaitDuration."));
        }, typeof VueYandexMaps.settings.value.mapsScriptWaitDuration === "number" ? VueYandexMaps.settings.value.mapsScriptWaitDuration : 5e3);
        timeoutCallback == null ? void 0 : timeoutCallback(timeout, false);
      }
      watch(VueYandexMaps.isLoaded, () => {
        if (timeout) {
          clearTimeout(timeout);
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        }
        if (VueYandexMaps.loadStatus.value === "loaded") {
          resolve();
        } else {
          reject(VueYandexMaps.loadError);
        }
      }, {
        immediate: true
      });
    } else {
      resolve();
    }
  });
}
function waitTillMapInit({
  map: _map,
  timeoutCallback
} = {}) {
  if (!_map && !getCurrentInstance()) {
    throwException({
      text: "onMapInit must be only called on runtime.",
      isInternal: true
    });
  }
  if (typeof window === "undefined") {
    throwException({
      text: "waitTillMapInit cannot be called on SSR.",
      isInternal: true
    });
  }
  const map = _map || injectMap();
  if (map.value)
    return;
  return new Promise((resolve, reject) => {
    let timeout;
    if (VueYandexMaps.settings.value.mapsRenderWaitDuration !== false) {
      timeout = setTimeout(() => {
        timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        reject(new VueYandexMaps.YandexMapException("Was not able to wait for map initialization in waitTillMapInit. You can change this behaviour by using mapsRenderWaitDuration."));
      }, typeof VueYandexMaps.settings.value.mapsRenderWaitDuration === "number" ? VueYandexMaps.settings.value.mapsRenderWaitDuration : 5e3);
      timeoutCallback == null ? void 0 : timeoutCallback(timeout, false);
    }
    let watcher;
    watcher = watch(map, () => {
      if (map.value) {
        watcher == null ? void 0 : watcher();
        if (timeout) {
          clearTimeout(timeout);
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        }
        resolve();
      }
    }, {
      immediate: true
    });
  });
}
function deleteMapChild({
  children,
  isMercator,
  root
}) {
  var _a;
  if (!root) {
    throwException({
      text: "Failed to execute deleteMapChild due to destroyed root",
      isInternal: true
    });
  }
  if (children && !isMercator) {
    if (typeof (root == null ? void 0 : root.value) === "object" && Array.isArray(root.value)) {
      root.value = root.value.filter((x) => x !== children);
    } else {
      (_a = root.value) == null ? void 0 : _a.removeChild(children);
    }
  } else if (root.value && children && isMercator && "update" in root.value) {
    root.value.update({
      projection: void 0
    });
  }
}
async function setupMapChildren({
  returnOnly,
  willDeleteByHand,
  strictMapRoot,
  requiredImport,
  createFunction,
  settings,
  settingsUpdateIgnoreKeys,
  isLayer,
  isMercator,
  isMapRoot,
  mapRootRef,
  duplicateInit
}) {
  if (!getCurrentInstance()) {
    throwException({
      text: "setupMapChildren must be only called on runtime.",
      isInternal: true
    });
  }
  const children = shallowRef();
  const mapRoot = inject("mapRoot", null);
  const initPromises = inject("mapRootInitPromises", null);
  let childrenPromises;
  const map = injectMap();
  const layers = injectLayers();
  let timeouts = null;
  const timeoutCallback = (timeout, isDelete) => {
    if (!timeouts)
      timeouts = /* @__PURE__ */ new Set();
    if (!isDelete)
      timeouts.add(timeout);
    else
      timeouts.delete(timeout);
  };
  if (isMapRoot && !duplicateInit) {
    provide("mapRoot", mapRootRef || children);
    childrenPromises = shallowRef([]);
    provide("mapRootInitPromises", childrenPromises);
  }
  if (!returnOnly && !willDeleteByHand) {
    onBeforeUnmount(() => {
      if (children.value) {
        deleteMapChild({
          children: children.value,
          isMercator,
          root: (mapRoot == null ? void 0 : mapRoot.value) ? mapRoot : map
        });
      }
      if (timeouts == null ? void 0 : timeouts.size) {
        timeouts.forEach((timeout) => clearTimeout(timeout));
        timeouts.clear();
      }
    });
  }
  if (settings) {
    let lastSettings = copy(toRaw(settings.value));
    watch(settings, (value) => {
      if (!value)
        return;
      const settingsDiff = Object.keys(diff(lastSettings, value));
      if (settingsDiff.length === 0)
        return;
      const updatedSettings = { ...value };
      for (const key in updatedSettings) {
        if (!settingsDiff.includes(key))
          delete updatedSettings[key];
      }
      const ignoreKeys = settingsUpdateIgnoreKeys && (isRef(settingsUpdateIgnoreKeys) ? settingsUpdateIgnoreKeys.value : settingsUpdateIgnoreKeys);
      if (ignoreKeys)
        excludeKeys(updatedSettings, ignoreKeys);
      if (Object.keys(updatedSettings).length === 0)
        return;
      lastSettings = toRaw(copy(value));
      if (children.value && "update" in children.value)
        children.value.update(updatedSettings);
    }, { deep: true });
  }
  if (!isLayer && !isMercator) {
    await waitTillMapInit({ timeoutCallback });
    if (!map.value) {
      throwException({
        text: "map is undefined in setupMapChildren.",
        isInternal: true
      });
    }
  } else {
    await waitTillYmapInit({ timeoutCallback });
  }
  if (strictMapRoot) {
    if (!(mapRoot == null ? void 0 : mapRoot.value))
      await nextTick();
    if (!(mapRoot == null ? void 0 : mapRoot.value)) {
      throwException({
        text: "mapRoot is undefined in setupMapChildren.",
        isInternal: true
      });
    }
  }
  if (isMapRoot) {
    await nextTick();
    await Promise.all((childrenPromises == null ? void 0 : childrenPromises.value) || []);
  }
  let importData;
  if (requiredImport) {
    const importPromise = requiredImport();
    if (initPromises == null ? void 0 : initPromises.value)
      initPromises.value.push(Promise.resolve(importPromise));
    importData = await importPromise;
  }
  children.value = createFunction(importData);
  if (!returnOnly && map.value && !isMercator) {
    if (initPromises == null ? void 0 : initPromises.value) {
      await Promise.all(initPromises.value);
      if (!requiredImport)
        await nextTick();
    }
    if (typeof (mapRoot == null ? void 0 : mapRoot.value) === "object" && Array.isArray(mapRoot.value)) {
      mapRoot.value = [
        ...mapRoot.value,
        children.value
      ];
    } else {
      ((mapRoot == null ? void 0 : mapRoot.value) || map.value).addChild(children.value);
    }
  } else if (isLayer) {
    layers.value.push(children.value);
  } else if (isMercator && map.value) {
    map.value.update({
      projection: children.value
    });
  }
  return children.value;
}
const _sfc_main$l = defineComponent({
  name: "YandexMapListener",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapListener;
    onMounted(async () => {
      mapListener = await setupMapChildren({
        createFunction: () => new ymaps3.YMapListener(props.settings || {}),
        settings: computed(() => props.settings)
      });
      emit("input", mapListener);
      emit("update:modelValue", mapListener);
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$k = defineComponent({
  name: "YandexMapDefaultFeaturesLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultFeaturesLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$j = defineComponent({
  name: "YandexMapDefaultSchemeLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultSchemeLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$i = defineComponent({
  name: "YandexMapDefaultSatelliteLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultSatelliteLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$h = defineComponent({
  name: "YandexMapTileDataSource",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.id) {
        throwException({
          text: "You must specify id in YandexMapTileDataSource settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapTileDataSource(props.settings),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$g = defineComponent({
  name: "YandexMapFeatureDataSource",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.id) {
        throwException({
          text: "You must specify id in YandexMapFeatureDataSource settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapFeatureDataSource(props.settings),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$f = defineComponent({
  name: "YandexMapLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      if (!props.settings.type) {
        throwException({
          text: "You must specify type in YandexMapLayer settings"
        });
      }
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
function getMarkerContainerProps({
  position,
  containerAttrs,
  wrapperAttrs,
  zeroSizes
}) {
  const root = {
    class: ["__ymap-marker"],
    style: {}
  };
  const children = {
    class: ["__ymap-marker_wrapper"],
    style: {}
  };
  const isDefaultPosition = position === "default" || position === "default default";
  if (position && !isDefaultPosition) {
    if (position.startsWith("translate")) {
      children.style.transform = position;
    } else {
      let translateX = 0;
      let translateY = 0;
      const splitted = position.split(" ");
      for (let i = 0; i < splitted.length; i++) {
        let local = 0;
        const item = splitted[i];
        switch (item) {
          case "top":
          case "left":
            local = -100;
            break;
          case "top-center":
          case "left-center":
            local = -50;
            break;
          case "bottom":
          case "right":
            local = 100;
            break;
          case "bottom-center":
          case "right-center":
            local = 50;
            break;
          default:
            local = 0;
        }
        if (item.startsWith("left") || item.startsWith("right"))
          translateX = local;
        else
          translateY = local;
      }
      children.style.transform = `translate(${translateX}%, ${translateY}%)`;
    }
  }
  if (zeroSizes === true || zeroSizes !== false && position && !isDefaultPosition) {
    root.style.width = "0";
    root.style.height = "0";
    if (children.style.transform)
      children.style.width = "fit-content";
  }
  const attrs = {
    root: { ...containerAttrs ?? {} },
    children: { ...wrapperAttrs ?? {} }
  };
  for (const [key, value] of Object.entries(attrs)) {
    const obj = key === "root" ? root : children;
    if (value.class) {
      if (!Array.isArray(value.class))
        value.class = [value.class];
      value.class = [
        ...obj.class,
        ...value.class
      ];
    }
    if (value == null ? void 0 : value.style) {
      if (typeof value.style !== "object" || Array.isArray(value.style)) {
        console.warn(`Style property was given in ${key} of marker, but it is not an object. Style of this prop can only be an object, therefore it was ignored.`);
      } else {
        value.style = {
          ...obj.style,
          ...value.style
        };
      }
    }
    Object.assign(obj, value);
  }
  return {
    root,
    children
  };
}
function excludeYandexMarkerProps(props) {
  props = { ...props };
  const toExclude = {
    position: true,
    containerAttrs: true,
    wrapperAttrs: true,
    zeroSizes: true
  };
  for (const excluded in toExclude) {
    if (excluded in props)
      delete props[excluded];
  }
  return props;
}
const _sfc_main$e = defineComponent({
  name: "YandexMapMarker",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    },
    /**
     * @description Sets translate(%, %) to marker to align it properly.
     *
     * If you want to make aligment to be like Yandex Maps 2.0, set this property to "top left-center".
     * @default default (as goes in Yandex by default)
     */
    position: {
      type: String
    },
    /**
     * @description Allows you to add any attributes to <div class="__ymap-marker"> container.
     *
     * Important: to pass styles, you must use object-style prop instead of string.
     */
    containerAttrs: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description Allows you to add any attributes to <div class="__ymap-marker_wrapper"> container.
     *
     * Important: to pass styles, you must use object-style prop instead of string.
     */
    wrapperAttrs: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description Will add width and height: 0 to container.
     *
     * Null enables default behaviour, false disables it completely (even if position is specified).
     *
     * @default true if position is specified, false otherwise
     */
    zeroSizes: {
      type: Boolean,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      if (!props.settings.coordinates) {
        throwException({
          text: "You must specify coordinates in YandexMapMarker settings"
        });
      }
      mapChildren = await setupMapChildren({
        settings: computed(() => props.settings),
        createFunction: () => new ymaps3.YMapMarker(props.settings, element.value)
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    watch(element, () => {
      var _a;
      if (element.value)
        (_a = element.value.parentNode) == null ? void 0 : _a.removeChild(element.value);
    });
    const rootProps = computed(() => getMarkerContainerProps({
      position: props.position,
      containerAttrs: props.containerAttrs,
      wrapperAttrs: props.wrapperAttrs,
      zeroSizes: props.zeroSizes
    }));
    return () => {
      var _a;
      return h("div", {
        ...rootProps.value.root,
        ref: element
      }, [
        h("div", {
          ...rootProps.value.children
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
const _sfc_main$d = defineComponent({
  name: "YandexMapDefaultMarker",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    const popup = ref(null);
    const closeFunc = ref(() => {
    });
    const contentFunc = (close) => {
      closeFunc.value = close;
      return popup.value;
    };
    const getSettings = computed(() => {
      const settings = { ...props.settings };
      if (settings.popup && (typeof settings.popup.content === "undefined" || settings.popup.content === "fromSlot") && popup.value) {
        settings.popup = {
          ...settings.popup,
          content: contentFunc
        };
      }
      return settings;
    });
    onMounted(async () => {
      if (!props.settings.coordinates) {
        throwException({
          text: "You must specify coordinates in YandexMapDefaultMarker settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: ({ YMapDefaultMarker: Marker }) => new Marker(getSettings.value),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-markers@0.0.1"),
        settings: getSettings
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    watch(popup, () => {
      var _a;
      if (popup.value)
        (_a = popup.value.parentNode) == null ? void 0 : _a.removeChild(popup.value);
    });
    return () => {
      var _a;
      return h("div", {
        ref: popup
      }, (_a = slots.popup) == null ? void 0 : _a.call(slots, { close: closeFunc.value }));
    };
  }
});
const _sfc_main$c = defineComponent({
  name: "YandexMapFeature",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.geometry) {
        throwException({
          text: "You must specify geometry in YandexMapFeature settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapFeature(props.settings),
        settings: computed(() => props.settings)
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$b = defineComponent({
  name: "YandexMapControls",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    onMounted(async () => {
      if (!props.settings.position) {
        throwException({
          text: "You must specify position in YandexMapControls settings"
        });
      }
      mapChildren.value = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControls(props.settings),
        isMapRoot: true,
        settings: computed(() => props.settings)
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    });
    return () => {
      var _a;
      return mapChildren.value ? h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {})) : h("div");
    };
  }
});
const _sfc_main$a = defineComponent({
  name: "YandexMapControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => {
          const control = new ymaps3.YMapControl();
          class YMapSomeController extends ymaps3.YMapEntity {
            _onAttach() {
              this._element = element.value;
              this._detachDom = ymaps3.useDomContext(this, this._element);
            }
            _onDetach() {
              this._detachDom();
              this._detachDom = null;
              this._element = null;
            }
          }
          control.addChild(new YMapSomeController({}));
          return control;
        },
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", {
        ref: element
      }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$9 = defineComponent({
  name: "YandexMapControlButton",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControlButton({
          ...props.settings,
          element: element.value
        }),
        settings: computed(() => ({
          ...props.settings,
          element: element.value
        })),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", {
        ref: element
      }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$8 = defineComponent({
  name: "YandexMapGeolocationControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: (controls) => new controls.YMapGeolocationControl(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls@0.0.1"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$7 = defineComponent({
  name: "YandexMapZoomControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: (controls) => new controls.YMapZoomControl(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls@0.0.1"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$6 = defineComponent({
  name: "YandexMapCartesianProjection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    bounds: {
      type: Array,
      required: true
    },
    cycled: {
      type: Array
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    const projection = inject("projection");
    onMounted(async () => {
      if (!projection)
        return;
      const cartesian = await setupMapChildren({
        isMercator: true,
        createFunction: ({ Cartesian: CartesianClass }) => new CartesianClass(props.bounds, props.cycled),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-cartesian-projection@0.0.1")
      });
      projection.value = cartesian;
      emit("input", cartesian);
      emit("update:modelValue", cartesian);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$5 = defineComponent({
  name: "YandexMapSphericalMercatorProjection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    hold(status) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    const projection = inject("projection");
    onMounted(async () => {
      if (!projection) {
        hold.value--;
        return;
      }
      const mercator = await setupMapChildren({
        isMercator: true,
        createFunction: ({ SphericalMercator: Mercator }) => new Mercator(),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-spherical-mercator-projection@0.0.1")
      });
      projection.value = mercator;
      emit("input", mercator);
      emit("update:modelValue", mercator);
      hold.value--;
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$4 = defineComponent({
  name: "YandexMapHint",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    // Property that you will set on YandexMapMarker or YandexMapFeature to display hint content
    hintProperty: {
      type: String,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    const element = shallowRef(null);
    const hintContent = shallowRef("");
    onMounted(async () => {
      await setupMapChildren({
        createFunction: ({
          YMapHint: MapHint,
          YMapHintContext
        }) => {
          mapChildren = new MapHint({
            hint: (object) => {
              var _a;
              return (_a = object == null ? void 0 : object.properties) == null ? void 0 : _a[props.hintProperty];
            }
          });
          class Hint extends ymaps3.YMapEntity {
            _onAttach() {
              const e = this;
              e._element = element.value;
              e._detachDom = ymaps3.useDomContext(e, e._element, null);
              e._watchContext(YMapHintContext, () => {
                var _a;
                hintContent.value = (_a = e._consumeContext(YMapHintContext)) == null ? void 0 : _a[props.hintProperty];
              }, { immediate: true });
            }
            _onDetach() {
              this._detachDom();
            }
          }
          mapChildren.addChild(new Hint({}));
          return mapChildren;
        },
        requiredImport: () => ymaps3.import("@yandex/ymaps3-hint@0.0.1")
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", {
        ref: element
      }, (_a = slots.default) == null ? void 0 : _a.call(slots, { content: hintContent.value }));
    };
  }
});
const _sfc_main$3 = defineComponent({
  name: "YandexMapOpenMapsButton",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: ({ YMapOpenMapsButton: OpenMapsButton }) => new OpenMapsButton(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls-extra"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$2 = defineComponent({
  name: "YandexMapClusterer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description All custom (non-settings) props are also supported
     */
    clusterMarkerProps: {
      type: Object,
      default: () => ({})
    },
    /**
     * @description Size of the grid division in pixels
     *
     * Used in settings.method via Yandex clusterByGrid method
     *
     * @see https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/clusterer/
     * @see https://yandex.ru/dev/jsapi30/doc/en/ref/packages/clusterer/
     */
    gridSize: {
      type: Number,
      default: 64
    },
    /**
     * @description Zooms to bounds of features of cluster
     */
    zoomOnClusterClick: {
      type: [Boolean, Object],
      default: false
    }
  },
  slots: Object,
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    // Exact features bounds returned on cluster click
    trueBounds(bounds) {
      return bounds.length === 2;
    },
    // Auto-corrected features bounds returned on cluster click
    updatedBounds(bounds) {
      return bounds.length === 2;
    }
  },
  setup(props, {
    slots,
    emit
  }) {
    const map = injectMap();
    const mapChildren = shallowRef(null);
    const entities = shallowRef([]);
    const clusterFeatures = ref([]);
    let _clusterByGrid;
    const tickTimeout = computed(() => props.settings.tickTimeout ?? 200);
    const getSettings = computed(() => {
      const settings = { ...props.settings };
      if (!settings.method && _clusterByGrid)
        settings.method = _clusterByGrid == null ? void 0 : _clusterByGrid({ gridSize: props.gridSize });
      settings.tickTimeout = tickTimeout.value;
      const marker = (feature) => {
        const entity = entities.value.find((x) => x._props.id === feature.id);
        if (!entity) {
          throwException({
            text: `No entity with id ${feature.id} (coordinates: ${feature.geometry.coordinates.join(", ")}) were found in YandexMapClusterer.`,
            isInternal: true,
            warn: true
          });
          return new ymaps3.YMapMarker({ coordinates: feature.geometry.coordinates });
        }
        return entity;
      };
      const cluster = (coordinates) => {
        const foundCluster = clusterFeatures.value.find((x) => JSON.stringify(x.clusterer.lnglat) === JSON.stringify(coordinates));
        if (!foundCluster) {
          throwException({
            text: `No element with coordinates of ${coordinates.join(", ")} were found in YandexMapClusterer.`,
            isInternal: true,
            warn: true
          });
          return new ymaps3.YMapMarker({ coordinates });
        }
        return foundCluster.element;
      };
      const features = entities.value.map((entity, i) => {
        if (!entity._props.id) {
          entity.update({
            id: Math.random().toString() + Date.now().toString()
          });
        }
        return {
          type: "Feature",
          id: entity._props.id,
          geometry: {
            type: "Point",
            coordinates: entity._props.coordinates
          },
          properties: "properties" in entity._props ? entity._props.properties : {}
        };
      });
      settings.onRender = (clustersList) => {
        clusterFeatures.value = clustersList.map((clusterer) => {
          var _a;
          return {
            clusterer,
            element: ((_a = clusterFeatures.value.find((x) => x.clusterer.clusterId === clusterer.clusterId)) == null ? void 0 : _a.element) || new ymaps3.YMapCollection({})
          };
        });
        if (props.settings.onRender)
          return props.settings.onRender(clustersList);
      };
      return {
        ...settings,
        marker,
        features,
        cluster
      };
    });
    const update = async () => {
      var _a, _b;
      await nextTick();
      (_a = mapChildren.value) == null ? void 0 : _a.update(getSettings.value);
      (_b = mapChildren.value) == null ? void 0 : _b._render();
      setTimeout(() => {
        var _a2;
        return (_a2 = mapChildren.value) == null ? void 0 : _a2._render();
      }, tickTimeout.value);
    };
    watch(() => [props.settings, props.gridSize], () => {
      update();
    }, {
      deep: true
    });
    const init = async () => {
      mapChildren.value = await setupMapChildren({
        createFunction: ({
          YMapClusterer: Clusterer,
          clusterByGrid: _clusterByGrid_
        }) => {
          _clusterByGrid = _clusterByGrid_;
          return new Clusterer(getSettings.value);
        },
        requiredImport: () => ymaps3.import("@yandex/ymaps3-clusterer@0.0.1"),
        isMapRoot: true,
        mapRootRef: entities
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    };
    watch(entities, async () => {
      await nextTick();
      update();
    });
    onMounted(() => {
      init();
    });
    return () => {
      var _a, _b, _c, _d, _e;
      if (!mapChildren.value)
        return h("div");
      const features = clusterFeatures.value.filter((x) => x.clusterer.features.length > 1);
      const containerProps = getMarkerContainerProps({
        position: ((_a = props.clusterMarkerProps) == null ? void 0 : _a.position) ?? "top-center left-center",
        containerAttrs: (_b = props.clusterMarkerProps) == null ? void 0 : _b.containerAttrs,
        wrapperAttrs: (_c = props.clusterMarkerProps) == null ? void 0 : _c.wrapperAttrs,
        zeroSizes: (_d = props.clusterMarkerProps) == null ? void 0 : _d.zeroSizes
      });
      const clusterSlots = features.map(({
        clusterer,
        element
      }, index) => {
        var _a2;
        return h(
          "div",
          {
            ...containerProps.root,
            key: `${clusterer.clusterId}_${index}_${clusterer.features.length}_${clusterer.lnglat.join(",")}`,
            ref: async (item) => {
              if (!item)
                return;
              await nextTick();
              try {
                element.children.forEach((x) => element.removeChild(x));
                element.addChild(new ymaps3.YMapMarker({
                  ...excludeYandexMarkerProps(props.clusterMarkerProps),
                  coordinates: clusterer.lnglat,
                  onClick: async (e) => {
                    var _a3, _b2, _c2, _d2;
                    (_b2 = (_a3 = props.clusterMarkerProps).onClick) == null ? void 0 : _b2.call(_a3, e);
                    if (clusterer.features.length >= 2) {
                      const {
                        minLongitude,
                        minLatitude,
                        maxLongitude,
                        maxLatitude
                      } = clusterer.features.map((x) => x.geometry.coordinates).reduce(
                        (acc, [longitude, latitude]) => ({
                          minLongitude: Math.min(acc.minLongitude, longitude),
                          minLatitude: Math.min(acc.minLatitude, latitude),
                          maxLongitude: Math.max(acc.maxLongitude, longitude),
                          maxLatitude: Math.max(acc.maxLatitude, latitude)
                        }),
                        {
                          minLongitude: Infinity,
                          minLatitude: Infinity,
                          maxLongitude: -Infinity,
                          maxLatitude: -Infinity
                        }
                      );
                      const settings = typeof props.zoomOnClusterClick === "object" ? props.zoomOnClusterClick : {};
                      const bounds = [[minLongitude, maxLatitude], [maxLongitude, minLatitude]];
                      emit("trueBounds", bounds);
                      if (!props.zoomOnClusterClick)
                        return;
                      const defaultDuration = settings.duration ?? 500;
                      if (settings.strategy === "boundsCorrect") {
                        const latDiff = maxLatitude - minLatitude;
                        const longDiff = maxLongitude - minLongitude;
                        const updatedBounds = [[minLongitude - longDiff, maxLatitude - latDiff], [maxLongitude + longDiff, minLatitude + latDiff]];
                        emit("updatedBounds", updatedBounds);
                        (_c2 = map.value) == null ? void 0 : _c2.setLocation({
                          bounds: updatedBounds,
                          duration: defaultDuration,
                          easing: settings.easing
                        });
                      } else {
                        let { center, zoom } = await useYMapsLocationFromBounds({
                          bounds,
                          map: map.value
                        });
                        const originalZoom = zoom;
                        zoom = Math.floor(zoom);
                        const diff2 = originalZoom - zoom;
                        if (!settings.disableMinimalZoomCorrectDiff && diff2 < 0.5) {
                          zoom -= 1;
                        }
                        (_d2 = map.value) == null ? void 0 : _d2.setLocation({
                          center,
                          zoom,
                          duration: defaultDuration,
                          easing: settings.easing
                        });
                        await sleep(defaultDuration + 50);
                        if (map.value)
                          emit("updatedBounds", map.value.bounds);
                      }
                    }
                  }
                }, item));
              } catch (e) {
                console.error(e);
              }
            },
            attrs: {
              coordinates: JSON.stringify(clusterer.lnglat)
            },
            // @ts-ignore
            coordinates: JSON.stringify(clusterer.lnglat)
          },
          [
            h("div", {
              ...containerProps.children
            }, (_a2 = slots.cluster) == null ? void 0 : _a2.call(slots, {
              clusterer,
              coordinates: clusterer.lnglat,
              length: clusterer.features.length
            }))
          ]
        );
      });
      return h("div", [
        ...((_e = slots.default) == null ? void 0 : _e.call(slots, {})) || [],
        h("div", {
          key: features.map((x) => x.clusterer.clusterId).join(",")
        }, [clusterSlots])
      ]);
    };
  }
});
const _sfc_main$1 = defineComponent({
  name: "YandexMapCollection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    onMounted(async () => {
      mapChildren.value = await setupMapChildren({
        createFunction: () => new ymaps3.YMapCollection({}),
        isMapRoot: true
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    });
    return () => {
      var _a;
      if (!mapChildren.value)
        return h("div");
      return h("div", (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main = defineComponent({
  name: "YandexMapEntity",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => {
          class Entity extends ymaps3.YMapEntity {
            _onAttach() {
              this._element = element.value;
              this._detachDom = ymaps3.useDomContext(this, this._element);
            }
            _onDetach() {
              this._detachDom();
              this._detachDom = null;
              this._element = null;
            }
          }
          return new Entity({});
        }
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return h("div", {
        ref: element
      }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
export {
  VueYandexMaps,
  _sfc_main$m as YandexMap,
  _sfc_main$6 as YandexMapCartesianProjection,
  _sfc_main$2 as YandexMapClusterer,
  _sfc_main$1 as YandexMapCollection,
  _sfc_main$a as YandexMapControl,
  _sfc_main$9 as YandexMapControlButton,
  _sfc_main$b as YandexMapControls,
  _sfc_main$k as YandexMapDefaultFeaturesLayer,
  _sfc_main$d as YandexMapDefaultMarker,
  _sfc_main$i as YandexMapDefaultSatelliteLayer,
  _sfc_main$j as YandexMapDefaultSchemeLayer,
  _sfc_main as YandexMapEntity,
  _sfc_main$c as YandexMapFeature,
  _sfc_main$g as YandexMapFeatureDataSource,
  _sfc_main$8 as YandexMapGeolocationControl,
  _sfc_main$4 as YandexMapHint,
  _sfc_main$f as YandexMapLayer,
  _sfc_main$l as YandexMapListener,
  _sfc_main$e as YandexMapMarker,
  _sfc_main$3 as YandexMapOpenMapsButton,
  _sfc_main$5 as YandexMapSphericalMercatorProjection,
  _sfc_main$h as YandexMapTileDataSource,
  _sfc_main$7 as YandexMapZoomControl,
  createYmaps,
  createYmapsOptions,
  createYmapsVue2,
  initYmaps,
  useYMapsLocationFromBounds
};
