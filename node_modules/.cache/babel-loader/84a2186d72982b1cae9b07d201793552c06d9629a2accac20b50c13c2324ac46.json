{"ast":null,"code":"/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */\nconst parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */\nconst coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */\nconst siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */\nconst animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */\nconst intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */\nconst intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */\nconst options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */\nconst debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */\nconst enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */\nlet root;\n/**\n * The rootâ€™s XY scroll positions.\n */\nlet scrollX = 0;\nlet scrollY = 0;\n/**\n * Used to sign an element as the target.\n */\nconst TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */\nconst DEL = \"__aa_del\";\n/**\n * Used to sign an element as being \"new\". When an element is removed from the\n * dom, but may cycle back in we can sign it with new to ensure the next time\n * it is recognized we consider it new.\n */\nconst NEW = \"__aa_new\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */\nconst handleMutations = mutations => {\n  const elements = getElements(mutations);\n  // If elements is \"false\" that means this mutation that should be ignored.\n  if (elements) {\n    elements.forEach(el => animate(el));\n  }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */\nconst handleResizes = entries => {\n  entries.forEach(entry => {\n    if (entry.target === root) updateAllPos();\n    if (coords.has(entry.target)) updatePos(entry.target);\n  });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */\nfunction observePosition(el) {\n  const oldObserver = intersections.get(el);\n  oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n  let rect = coords.get(el);\n  let invocations = 0;\n  const buffer = 5;\n  if (!rect) {\n    rect = getCoords(el);\n    coords.set(el, rect);\n  }\n  const {\n    offsetWidth,\n    offsetHeight\n  } = root;\n  const rootMargins = [rect.top - buffer, offsetWidth - (rect.left + buffer + rect.width), offsetHeight - (rect.top + buffer + rect.height), rect.left - buffer];\n  const rootMargin = rootMargins.map(px => `${-1 * Math.floor(px)}px`).join(\" \");\n  const observer = new IntersectionObserver(() => {\n    ++invocations > 1 && updatePos(el);\n  }, {\n    root,\n    threshold: 1,\n    rootMargin\n  });\n  observer.observe(el);\n  intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */\nfunction updatePos(el) {\n  clearTimeout(debounces.get(el));\n  const optionsOrPlugin = getOptions(el);\n  const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;\n  debounces.set(el, setTimeout(async () => {\n    const currentAnimation = animations.get(el);\n    try {\n      await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);\n      coords.set(el, getCoords(el));\n      observePosition(el);\n    } catch {\n      // ignore errors as the `.finished` promise is rejected when animations were cancelled\n    }\n  }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */\nfunction updateAllPos() {\n  clearTimeout(debounces.get(root));\n  debounces.set(root, setTimeout(() => {\n    parents.forEach(parent => forEach(parent, el => lowPriority(() => updatePos(el))));\n  }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */\nfunction poll(el) {\n  setTimeout(() => {\n    intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2000));\n  }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */\nfunction lowPriority(callback) {\n  if (typeof requestIdleCallback === \"function\") {\n    requestIdleCallback(() => callback());\n  } else {\n    requestAnimationFrame(() => callback());\n  }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */\nlet mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */\nlet resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */\nif (typeof window !== \"undefined\") {\n  root = document.documentElement;\n  mutations = new MutationObserver(handleMutations);\n  resize = new ResizeObserver(handleResizes);\n  window.addEventListener(\"scroll\", () => {\n    scrollY = window.scrollY;\n    scrollX = window.scrollX;\n  });\n  resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */\nfunction getElements(mutations) {\n  const observedNodes = mutations.reduce((nodes, mutation) => {\n    return [...nodes, ...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)];\n  }, []);\n  // Short circuit if _only_ comment nodes are observed\n  const onlyCommentNodesObserved = observedNodes.every(node => node.nodeName === \"#comment\");\n  if (onlyCommentNodesObserved) return false;\n  return mutations.reduce((elements, mutation) => {\n    // Short circuit if we find a purposefully deleted node.\n    if (elements === false) return false;\n    if (mutation.target instanceof Element) {\n      target(mutation.target);\n      if (!elements.has(mutation.target)) {\n        elements.add(mutation.target);\n        for (let i = 0; i < mutation.target.children.length; i++) {\n          const child = mutation.target.children.item(i);\n          if (!child) continue;\n          if (DEL in child) {\n            return false;\n          }\n          target(mutation.target, child);\n          elements.add(child);\n        }\n      }\n      if (mutation.removedNodes.length) {\n        for (let i = 0; i < mutation.removedNodes.length; i++) {\n          const child = mutation.removedNodes[i];\n          if (DEL in child) {\n            return false;\n          }\n          if (child instanceof Element) {\n            elements.add(child);\n            target(mutation.target, child);\n            siblings.set(child, [mutation.previousSibling, mutation.nextSibling]);\n          }\n        }\n      }\n    }\n    return elements;\n  }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */\nfunction target(el, child) {\n  if (!child && !(TGT in el)) Object.defineProperty(el, TGT, {\n    value: el\n  });else if (child && !(TGT in child)) Object.defineProperty(child, TGT, {\n    value: el\n  });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */\nfunction animate(el) {\n  var _a;\n  const isMounted = el.isConnected;\n  const preExisting = coords.has(el);\n  if (isMounted && siblings.has(el)) siblings.delete(el);\n  if (animations.has(el)) {\n    (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n  }\n  if (NEW in el) {\n    add(el);\n  } else if (preExisting && isMounted) {\n    remain(el);\n  } else if (preExisting && !isMounted) {\n    remove(el);\n  } else {\n    add(el);\n  }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */\nfunction raw(str) {\n  return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the scroll offset of elements\n * @param el - Element\n * @returns\n */\nfunction getScrollOffset(el) {\n  let p = el.parentElement;\n  while (p) {\n    if (p.scrollLeft || p.scrollTop) {\n      return {\n        x: p.scrollLeft,\n        y: p.scrollTop\n      };\n    }\n    p = p.parentElement;\n  }\n  return {\n    x: 0,\n    y: 0\n  };\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */\nfunction getCoords(el) {\n  const rect = el.getBoundingClientRect();\n  const {\n    x,\n    y\n  } = getScrollOffset(el);\n  return {\n    top: rect.top + y,\n    left: rect.left + x,\n    width: rect.width,\n    height: rect.height\n  };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */\nfunction getTransitionSizes(el, oldCoords, newCoords) {\n  let widthFrom = oldCoords.width;\n  let heightFrom = oldCoords.height;\n  let widthTo = newCoords.width;\n  let heightTo = newCoords.height;\n  const styles = getComputedStyle(el);\n  const sizing = styles.getPropertyValue(\"box-sizing\");\n  if (sizing === \"content-box\") {\n    const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);\n    const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);\n    widthFrom -= paddingX;\n    widthTo -= paddingX;\n    heightFrom -= paddingY;\n    heightTo -= paddingY;\n  }\n  return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */\nfunction getOptions(el) {\n  return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : {\n    duration: 250,\n    easing: \"ease-in-out\"\n  };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */\nfunction getTarget(el) {\n  if (TGT in el) return el[TGT];\n  return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */\nfunction isEnabled(el) {\n  const target = getTarget(el);\n  return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */\nfunction forEach(parent, ...callbacks) {\n  callbacks.forEach(callback => callback(parent, options.has(parent)));\n  for (let i = 0; i < parent.children.length; i++) {\n    const child = parent.children.item(i);\n    if (child) {\n      callbacks.forEach(callback => callback(child, options.has(child)));\n    }\n  }\n}\n/**\n * Always return tuple to provide consistent interface\n */\nfunction getPluginTuple(pluginReturn) {\n  if (Array.isArray(pluginReturn)) return pluginReturn;\n  return [pluginReturn];\n}\n/**\n * Determine if config is plugin\n */\nfunction isPlugin(config) {\n  return typeof config === \"function\";\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */\nfunction remain(el) {\n  const oldCoords = coords.get(el);\n  const newCoords = getCoords(el);\n  if (!isEnabled(el)) return coords.set(el, newCoords);\n  let animation;\n  if (!oldCoords) return;\n  const pluginOrOptions = getOptions(el);\n  if (typeof pluginOrOptions !== \"function\") {\n    const deltaX = oldCoords.left - newCoords.left;\n    const deltaY = oldCoords.top - newCoords.top;\n    const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n    const start = {\n      transform: `translate(${deltaX}px, ${deltaY}px)`\n    };\n    const end = {\n      transform: `translate(0, 0)`\n    };\n    if (widthFrom !== widthTo) {\n      start.width = `${widthFrom}px`;\n      end.width = `${widthTo}px`;\n    }\n    if (heightFrom !== heightTo) {\n      start.height = `${heightFrom}px`;\n      end.height = `${heightTo}px`;\n    }\n    animation = el.animate([start, end], {\n      duration: pluginOrOptions.duration,\n      easing: pluginOrOptions.easing\n    });\n  } else {\n    const [keyframes] = getPluginTuple(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n    animation = new Animation(keyframes);\n    animation.play();\n  }\n  animations.set(el, animation);\n  coords.set(el, newCoords);\n  animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */\nfunction add(el) {\n  if (NEW in el) delete el[NEW];\n  const newCoords = getCoords(el);\n  coords.set(el, newCoords);\n  const pluginOrOptions = getOptions(el);\n  if (!isEnabled(el)) return;\n  let animation;\n  if (typeof pluginOrOptions !== \"function\") {\n    animation = el.animate([{\n      transform: \"scale(.98)\",\n      opacity: 0\n    }, {\n      transform: \"scale(0.98)\",\n      opacity: 0,\n      offset: 0.5\n    }, {\n      transform: \"scale(1)\",\n      opacity: 1\n    }], {\n      duration: pluginOrOptions.duration * 1.5,\n      easing: \"ease-in\"\n    });\n  } else {\n    const [keyframes] = getPluginTuple(pluginOrOptions(el, \"add\", newCoords));\n    animation = new Animation(keyframes);\n    animation.play();\n  }\n  animations.set(el, animation);\n  animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Clean up after removing an element from the dom.\n * @param el - Element being removed\n * @param styles - Optional styles that should be removed from the element.\n */\nfunction cleanUp(el, styles) {\n  var _a;\n  el.remove();\n  coords.delete(el);\n  siblings.delete(el);\n  animations.delete(el);\n  (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n  setTimeout(() => {\n    if (DEL in el) delete el[DEL];\n    Object.defineProperty(el, NEW, {\n      value: true,\n      configurable: true\n    });\n    if (styles && el instanceof HTMLElement) {\n      for (const style in styles) {\n        el.style[style] = \"\";\n      }\n    }\n  }, 0);\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */\nfunction remove(el) {\n  var _a;\n  if (!siblings.has(el) || !coords.has(el)) return;\n  const [prev, next] = siblings.get(el);\n  Object.defineProperty(el, DEL, {\n    value: true,\n    configurable: true\n  });\n  const finalX = window.scrollX;\n  const finalY = window.scrollY;\n  if (next && next.parentNode && next.parentNode instanceof Element) {\n    next.parentNode.insertBefore(el, next);\n  } else if (prev && prev.parentNode) {\n    prev.parentNode.appendChild(el);\n  } else {\n    (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n  }\n  if (!isEnabled(el)) return cleanUp(el);\n  const [top, left, width, height] = deletePosition(el);\n  const optionsOrPlugin = getOptions(el);\n  const oldCoords = coords.get(el);\n  if (finalX !== scrollX || finalY !== scrollY) {\n    adjustScroll(el, finalX, finalY, optionsOrPlugin);\n  }\n  let animation;\n  let styleReset = {\n    position: \"absolute\",\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    margin: \"0\",\n    pointerEvents: \"none\",\n    transformOrigin: \"center\",\n    zIndex: \"100\"\n  };\n  if (!isPlugin(optionsOrPlugin)) {\n    Object.assign(el.style, styleReset);\n    animation = el.animate([{\n      transform: \"scale(1)\",\n      opacity: 1\n    }, {\n      transform: \"scale(.98)\",\n      opacity: 0\n    }], {\n      duration: optionsOrPlugin.duration,\n      easing: \"ease-out\"\n    });\n  } else {\n    const [keyframes, options] = getPluginTuple(optionsOrPlugin(el, \"remove\", oldCoords));\n    if ((options === null || options === void 0 ? void 0 : options.styleReset) !== false) {\n      styleReset = (options === null || options === void 0 ? void 0 : options.styleReset) || styleReset;\n      Object.assign(el.style, styleReset);\n    }\n    animation = new Animation(keyframes);\n    animation.play();\n  }\n  animations.set(el, animation);\n  animation.addEventListener(\"finish\", cleanUp.bind(null, el, styleReset));\n}\n/**\n * If the element being removed is at the very bottom of the page, and the\n * the page was scrolled into a space being \"made available\" by the element\n * that was removed, the page scroll will have jumped up some amount. We need\n * to offset the jump by the amount that the page was \"automatically\" scrolled\n * up. We can do this by comparing the scroll position before and after the\n * element was removed, and then offsetting by that amount.\n *\n * @param el - The element being deleted\n * @param finalX - The final X scroll position\n * @param finalY - The final Y scroll position\n * @param optionsOrPlugin - The options or plugin\n * @returns\n */\nfunction adjustScroll(el, finalX, finalY, optionsOrPlugin) {\n  const scrollDeltaX = scrollX - finalX;\n  const scrollDeltaY = scrollY - finalY;\n  const scrollBefore = document.documentElement.style.scrollBehavior;\n  const scrollBehavior = getComputedStyle(root).scrollBehavior;\n  if (scrollBehavior === \"smooth\") {\n    document.documentElement.style.scrollBehavior = \"auto\";\n  }\n  window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);\n  if (!el.parentElement) return;\n  const parent = el.parentElement;\n  let lastHeight = parent.clientHeight;\n  let lastWidth = parent.clientWidth;\n  const startScroll = performance.now();\n  // Here we use a manual scroll animation to keep the element using the same\n  // easing and timing as the parentâ€™s scroll animation.\n  function smoothScroll() {\n    requestAnimationFrame(() => {\n      if (!isPlugin(optionsOrPlugin)) {\n        const deltaY = lastHeight - parent.clientHeight;\n        const deltaX = lastWidth - parent.clientWidth;\n        if (startScroll + optionsOrPlugin.duration > performance.now()) {\n          window.scrollTo({\n            left: window.scrollX - deltaX,\n            top: window.scrollY - deltaY\n          });\n          lastHeight = parent.clientHeight;\n          lastWidth = parent.clientWidth;\n          smoothScroll();\n        } else {\n          document.documentElement.style.scrollBehavior = scrollBefore;\n        }\n      }\n    });\n  }\n  smoothScroll();\n}\n/**\n * Determines the position of the element being removed.\n * @param el - The element being deleted\n * @returns\n */\nfunction deletePosition(el) {\n  const oldCoords = coords.get(el);\n  const [width,, height] = getTransitionSizes(el, oldCoords, getCoords(el));\n  let offsetParent = el.parentElement;\n  while (offsetParent && (getComputedStyle(offsetParent).position === \"static\" || offsetParent instanceof HTMLBodyElement)) {\n    offsetParent = offsetParent.parentElement;\n  }\n  if (!offsetParent) offsetParent = document.body;\n  const parentStyles = getComputedStyle(offsetParent);\n  const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n  const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);\n  const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);\n  return [top, left, width, height];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */\nfunction autoAnimate(el, config = {}) {\n  if (mutations && resize) {\n    const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n    const isDisabledDueToReduceMotion = mediaQuery.matches && !isPlugin(config) && !config.disrespectUserMotionPreference;\n    if (!isDisabledDueToReduceMotion) {\n      enabled.add(el);\n      if (getComputedStyle(el).position === \"static\") {\n        Object.assign(el.style, {\n          position: \"relative\"\n        });\n      }\n      forEach(el, updatePos, poll, element => resize === null || resize === void 0 ? void 0 : resize.observe(element));\n      if (isPlugin(config)) {\n        options.set(el, config);\n      } else {\n        options.set(el, {\n          duration: 250,\n          easing: \"ease-in-out\",\n          ...config\n        });\n      }\n      mutations.observe(el, {\n        childList: true\n      });\n      parents.add(el);\n    }\n  }\n  return Object.freeze({\n    parent: el,\n    enable: () => {\n      enabled.add(el);\n    },\n    disable: () => {\n      enabled.delete(el);\n    },\n    isEnabled: () => enabled.has(el)\n  });\n}\n/**\n * The vue directive.\n */\nconst vAutoAnimate = {\n  mounted: (el, binding) => {\n    autoAnimate(el, binding.value || {});\n  },\n  // ignore ssr see #96:\n  getSSRProps: () => ({})\n};\nexport { autoAnimate as default, getTransitionSizes, vAutoAnimate };","map":{"version":3,"names":["parents","Set","coords","WeakMap","siblings","animations","intersections","intervals","options","debounces","enabled","WeakSet","root","scrollX","scrollY","TGT","DEL","NEW","handleMutations","mutations","elements","getElements","forEach","el","animate","handleResizes","entries","entry","target","updateAllPos","has","updatePos","observePosition","oldObserver","get","disconnect","rect","invocations","buffer","getCoords","set","offsetWidth","offsetHeight","rootMargins","top","left","width","height","rootMargin","map","px","Math","floor","join","observer","IntersectionObserver","threshold","observe","clearTimeout","optionsOrPlugin","getOptions","delay","isPlugin","duration","setTimeout","currentAnimation","finished","parent","lowPriority","poll","setInterval","bind","round","random","callback","requestIdleCallback","requestAnimationFrame","resize","window","document","documentElement","MutationObserver","ResizeObserver","addEventListener","observedNodes","reduce","nodes","mutation","Array","from","addedNodes","removedNodes","onlyCommentNodesObserved","every","node","nodeName","Element","add","i","children","length","child","item","previousSibling","nextSibling","Object","defineProperty","value","_a","isMounted","isConnected","preExisting","delete","cancel","remain","remove","raw","str","Number","replace","getScrollOffset","p","parentElement","scrollLeft","scrollTop","x","y","getBoundingClientRect","getTransitionSizes","oldCoords","newCoords","widthFrom","heightFrom","widthTo","heightTo","styles","getComputedStyle","sizing","getPropertyValue","paddingY","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","paddingX","paddingLeft","paddingRight","borderRightWidth","borderLeftWidth","easing","getTarget","undefined","isEnabled","callbacks","getPluginTuple","pluginReturn","isArray","config","animation","pluginOrOptions","deltaX","deltaY","start","transform","end","keyframes","Animation","play","opacity","offset","cleanUp","configurable","HTMLElement","style","prev","next","finalX","finalY","parentNode","insertBefore","appendChild","deletePosition","adjustScroll","styleReset","position","margin","pointerEvents","transformOrigin","zIndex","assign","scrollDeltaX","scrollDeltaY","scrollBefore","scrollBehavior","scrollTo","lastHeight","clientHeight","lastWidth","clientWidth","startScroll","performance","now","smoothScroll","offsetParent","HTMLBodyElement","body","parentStyles","parentCoords","autoAnimate","mediaQuery","matchMedia","isDisabledDueToReduceMotion","matches","disrespectUserMotionPreference","element","childList","freeze","enable","disable","vAutoAnimate","mounted","binding","getSSRProps","default"],"sources":["C:/gitPages/rol-shop/node_modules/@formkit/auto-animate/index.mjs"],"sourcesContent":["/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */\nconst parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */\nconst coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */\nconst siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */\nconst animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */\nconst intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */\nconst intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */\nconst options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */\nconst debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */\nconst enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */\nlet root;\n/**\n * The rootâ€™s XY scroll positions.\n */\nlet scrollX = 0;\nlet scrollY = 0;\n/**\n * Used to sign an element as the target.\n */\nconst TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */\nconst DEL = \"__aa_del\";\n/**\n * Used to sign an element as being \"new\". When an element is removed from the\n * dom, but may cycle back in we can sign it with new to ensure the next time\n * it is recognized we consider it new.\n */\nconst NEW = \"__aa_new\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */\nconst handleMutations = (mutations) => {\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el) => animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */\nconst handleResizes = (entries) => {\n    entries.forEach((entry) => {\n        if (entry.target === root)\n            updateAllPos();\n        if (coords.has(entry.target))\n            updatePos(entry.target);\n    });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */\nfunction observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer,\n    ];\n    const rootMargin = rootMargins\n        .map((px) => `${-1 * Math.floor(px)}px`)\n        .join(\" \");\n    const observer = new IntersectionObserver(() => {\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin,\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */\nfunction updatePos(el) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;\n    debounces.set(el, setTimeout(async () => {\n        const currentAnimation = animations.get(el);\n        try {\n            await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        }\n        catch {\n            // ignore errors as the `.finished` promise is rejected when animations were cancelled\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */\nfunction updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(() => {\n        parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */\nfunction poll(el) {\n    setTimeout(() => {\n        intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */\nfunction lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(() => callback());\n    }\n    else {\n        requestAnimationFrame(() => callback());\n    }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */\nlet mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */\nlet resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */\nif (typeof window !== \"undefined\") {\n    root = document.documentElement;\n    mutations = new MutationObserver(handleMutations);\n    resize = new ResizeObserver(handleResizes);\n    window.addEventListener(\"scroll\", () => {\n        scrollY = window.scrollY;\n        scrollX = window.scrollX;\n    });\n    resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */\nfunction getElements(mutations) {\n    const observedNodes = mutations.reduce((nodes, mutation) => {\n        return [\n            ...nodes,\n            ...Array.from(mutation.addedNodes),\n            ...Array.from(mutation.removedNodes),\n        ];\n    }, []);\n    // Short circuit if _only_ comment nodes are observed\n    const onlyCommentNodesObserved = observedNodes.every((node) => node.nodeName === \"#comment\");\n    if (onlyCommentNodesObserved)\n        return false;\n    return mutations.reduce((elements, mutation) => {\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false)\n            return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for (let i = 0; i < mutation.target.children.length; i++) {\n                    const child = mutation.target.children.item(i);\n                    if (!child)\n                        continue;\n                    if (DEL in child) {\n                        return false;\n                    }\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child) {\n                        return false;\n                    }\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling,\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */\nfunction target(el, child) {\n    if (!child && !(TGT in el))\n        Object.defineProperty(el, TGT, { value: el });\n    else if (child && !(TGT in child))\n        Object.defineProperty(child, TGT, { value: el });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */\nfunction animate(el) {\n    var _a;\n    const isMounted = el.isConnected;\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el))\n        siblings.delete(el);\n    if (animations.has(el)) {\n        (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    if (NEW in el) {\n        add(el);\n    }\n    else if (preExisting && isMounted) {\n        remain(el);\n    }\n    else if (preExisting && !isMounted) {\n        remove(el);\n    }\n    else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */\nfunction raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the scroll offset of elements\n * @param el - Element\n * @returns\n */\nfunction getScrollOffset(el) {\n    let p = el.parentElement;\n    while (p) {\n        if (p.scrollLeft || p.scrollTop) {\n            return { x: p.scrollLeft, y: p.scrollTop };\n        }\n        p = p.parentElement;\n    }\n    return { x: 0, y: 0 };\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */\nfunction getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    const { x, y } = getScrollOffset(el);\n    return {\n        top: rect.top + y,\n        left: rect.left + x,\n        width: rect.width,\n        height: rect.height,\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */\nfunction getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) +\n            raw(styles.paddingBottom) +\n            raw(styles.borderTopWidth) +\n            raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) +\n            raw(styles.paddingRight) +\n            raw(styles.borderRightWidth) +\n            raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */\nfunction getOptions(el) {\n    return TGT in el && options.has(el[TGT])\n        ? options.get(el[TGT])\n        : { duration: 250, easing: \"ease-in-out\" };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */\nfunction getTarget(el) {\n    if (TGT in el)\n        return el[TGT];\n    return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */\nfunction isEnabled(el) {\n    const target = getTarget(el);\n    return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */\nfunction forEach(parent, ...callbacks) {\n    callbacks.forEach((callback) => callback(parent, options.has(parent)));\n    for (let i = 0; i < parent.children.length; i++) {\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback) => callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * Always return tuple to provide consistent interface\n */\nfunction getPluginTuple(pluginReturn) {\n    if (Array.isArray(pluginReturn))\n        return pluginReturn;\n    return [pluginReturn];\n}\n/**\n * Determine if config is plugin\n */\nfunction isPlugin(config) {\n    return typeof config === \"function\";\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */\nfunction remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    if (!isEnabled(el))\n        return coords.set(el, newCoords);\n    let animation;\n    if (!oldCoords)\n        return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        const deltaX = oldCoords.left - newCoords.left;\n        const deltaY = oldCoords.top - newCoords.top;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaX}px, ${deltaY}px)`,\n        };\n        const end = {\n            transform: `translate(0, 0)`,\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([start, end], {\n            duration: pluginOrOptions.duration,\n            easing: pluginOrOptions.easing,\n        });\n    }\n    else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */\nfunction add(el) {\n    if (NEW in el)\n        delete el[NEW];\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    if (!isEnabled(el))\n        return;\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            { transform: \"scale(.98)\", opacity: 0 },\n            { transform: \"scale(0.98)\", opacity: 0, offset: 0.5 },\n            { transform: \"scale(1)\", opacity: 1 },\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\",\n        });\n    }\n    else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"add\", newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Clean up after removing an element from the dom.\n * @param el - Element being removed\n * @param styles - Optional styles that should be removed from the element.\n */\nfunction cleanUp(el, styles) {\n    var _a;\n    el.remove();\n    coords.delete(el);\n    siblings.delete(el);\n    animations.delete(el);\n    (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    setTimeout(() => {\n        if (DEL in el)\n            delete el[DEL];\n        Object.defineProperty(el, NEW, { value: true, configurable: true });\n        if (styles && el instanceof HTMLElement) {\n            for (const style in styles) {\n                el.style[style] = \"\";\n            }\n        }\n    }, 0);\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */\nfunction remove(el) {\n    var _a;\n    if (!siblings.has(el) || !coords.has(el))\n        return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, { value: true, configurable: true });\n    const finalX = window.scrollX;\n    const finalY = window.scrollY;\n    if (next && next.parentNode && next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    }\n    else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    }\n    else {\n        (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n    }\n    if (!isEnabled(el))\n        return cleanUp(el);\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    if (finalX !== scrollX || finalY !== scrollY) {\n        adjustScroll(el, finalX, finalY, optionsOrPlugin);\n    }\n    let animation;\n    let styleReset = {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: \"0\",\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: \"100\",\n    };\n    if (!isPlugin(optionsOrPlugin)) {\n        Object.assign(el.style, styleReset);\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1,\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0,\n            },\n        ], { duration: optionsOrPlugin.duration, easing: \"ease-out\" });\n    }\n    else {\n        const [keyframes, options] = getPluginTuple(optionsOrPlugin(el, \"remove\", oldCoords));\n        if ((options === null || options === void 0 ? void 0 : options.styleReset) !== false) {\n            styleReset = (options === null || options === void 0 ? void 0 : options.styleReset) || styleReset;\n            Object.assign(el.style, styleReset);\n        }\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", cleanUp.bind(null, el, styleReset));\n}\n/**\n * If the element being removed is at the very bottom of the page, and the\n * the page was scrolled into a space being \"made available\" by the element\n * that was removed, the page scroll will have jumped up some amount. We need\n * to offset the jump by the amount that the page was \"automatically\" scrolled\n * up. We can do this by comparing the scroll position before and after the\n * element was removed, and then offsetting by that amount.\n *\n * @param el - The element being deleted\n * @param finalX - The final X scroll position\n * @param finalY - The final Y scroll position\n * @param optionsOrPlugin - The options or plugin\n * @returns\n */\nfunction adjustScroll(el, finalX, finalY, optionsOrPlugin) {\n    const scrollDeltaX = scrollX - finalX;\n    const scrollDeltaY = scrollY - finalY;\n    const scrollBefore = document.documentElement.style.scrollBehavior;\n    const scrollBehavior = getComputedStyle(root).scrollBehavior;\n    if (scrollBehavior === \"smooth\") {\n        document.documentElement.style.scrollBehavior = \"auto\";\n    }\n    window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);\n    if (!el.parentElement)\n        return;\n    const parent = el.parentElement;\n    let lastHeight = parent.clientHeight;\n    let lastWidth = parent.clientWidth;\n    const startScroll = performance.now();\n    // Here we use a manual scroll animation to keep the element using the same\n    // easing and timing as the parentâ€™s scroll animation.\n    function smoothScroll() {\n        requestAnimationFrame(() => {\n            if (!isPlugin(optionsOrPlugin)) {\n                const deltaY = lastHeight - parent.clientHeight;\n                const deltaX = lastWidth - parent.clientWidth;\n                if (startScroll + optionsOrPlugin.duration > performance.now()) {\n                    window.scrollTo({\n                        left: window.scrollX - deltaX,\n                        top: window.scrollY - deltaY,\n                    });\n                    lastHeight = parent.clientHeight;\n                    lastWidth = parent.clientWidth;\n                    smoothScroll();\n                }\n                else {\n                    document.documentElement.style.scrollBehavior = scrollBefore;\n                }\n            }\n        });\n    }\n    smoothScroll();\n}\n/**\n * Determines the position of the element being removed.\n * @param el - The element being deleted\n * @returns\n */\nfunction deletePosition(el) {\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while (offsetParent &&\n        (getComputedStyle(offsetParent).position === \"static\" ||\n            offsetParent instanceof HTMLBodyElement)) {\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent)\n        offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) -\n        raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) -\n        raw(parentStyles.borderLeftWidth);\n    return [top, left, width, height];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */\nfunction autoAnimate(el, config = {}) {\n    if (mutations && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        const isDisabledDueToReduceMotion = mediaQuery.matches &&\n            !isPlugin(config) &&\n            !config.disrespectUserMotionPreference;\n        if (!isDisabledDueToReduceMotion) {\n            enabled.add(el);\n            if (getComputedStyle(el).position === \"static\") {\n                Object.assign(el.style, { position: \"relative\" });\n            }\n            forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));\n            if (isPlugin(config)) {\n                options.set(el, config);\n            }\n            else {\n                options.set(el, { duration: 250, easing: \"ease-in-out\", ...config });\n            }\n            mutations.observe(el, { childList: true });\n            parents.add(el);\n        }\n    }\n    return Object.freeze({\n        parent: el,\n        enable: () => {\n            enabled.add(el);\n        },\n        disable: () => {\n            enabled.delete(el);\n        },\n        isEnabled: () => enabled.has(el),\n    });\n}\n/**\n * The vue directive.\n */\nconst vAutoAnimate = {\n    mounted: (el, binding) => {\n        autoAnimate(el, binding.value || {});\n    },\n    // ignore ssr see #96:\n    getSSRProps: () => ({}),\n};\n\nexport { autoAnimate as default, getTransitionSizes, vAutoAnimate };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}